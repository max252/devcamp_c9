# Que es un Paquete NPM? y porque se utiliza?

![npm](images/npm.png)

**Node Package Manager (npm)** es un administrador de paquetes de JavaScript que gestiona las dependencias en proyectos escritos en Node.js.

Con este administrador, puede administrar la instalación, actualización y eliminación de paquetes (bibliotecas). En términos generales, npm es el registro de software más grande del mundo.

npm tiene tres componentes:

- Sitio web;
- interfaz de línea de comando (CLI);
- registro.

Desde el sitio web, puede encontrar paquetes, configurar perfiles y administrar otros aspectos de su experiencia npm. Por ejemplo, puede configurar una organización para controlar el acceso a paquetes públicos o privados.

La interfaz de línea de comandos (CLI) se ejecuta en la terminal a través de la cual los desarrolladores interactúan con npm.

El registro es una gran base de datos pública con software JavaScript y metainformación que lo acompaña.

## ¿Para qué se utiliza el Node Package Manager?

Los desarrolladores de software de código abierto de todo el mundo utilizan npm para compartir y tomar prestados paquetes.

Con npm puedes:

- adapte paquetes de código a sus aplicaciones o utilícelos en su forma original;
- descargue herramientas sin conexión que pueda utilizar inmediatamente;
- ejecutar paquetes sin descargarlos;
- compartir código con cualquier usuario de npm, independientemente de su ubicación;
- limitar el acceso al código proporcionándolo únicamente a desarrolladores individuales;
- crear organizaciones para gestionar el mantenimiento de paquetes, la creación de códigos y la mano de obra de los desarrolladores;
- formar equipos virtuales utilizando organizaciones;
- gestionar versiones y dependencias de código;
- actualizar rápidamente las aplicaciones al actualizar el código subyacente;
- encontrar múltiples formas de resolver el mismo problema;
- Encuentre otros desarrolladores que estén trabajando en problemas y proyectos similares.

## Beneficios de usar npm

Existen muchos beneficios al usar npm al desarrollar proyectos de Node.js:

- Fácil de instalar. npm viene con Node.js, por lo que la instalación solo lleva unos minutos.
- Gestión de dependencia. npm simplifica la gestión de dependencias, lo cual es especialmente importante para proyectos con una gran cantidad de módulos. Cada paquete en npm es una colección de archivos y dependencias que puedes instalar y usar en tu proyecto.
- Soporte para paquetes de publicación. npm permite a los desarrolladores publicar sus paquetes, lo que les ayuda a compartir sus bibliotecas y módulos con otros desarrolladores de todo el mundo.
- Gran cantidad de paquetes disponibles. npm ofrece acceso a más de 1,5 millones de paquetes, lo que permite a los desarrolladores encontrar rápida y fácilmente los módulos y bibliotecas que necesitan. Con npm puedes instalar paquetes desde el repositorio central de npm o desde archivos locales.
- Control de versiones. npm controla automáticamente las versiones de los paquetes, lo que permite a los desarrolladores evitar conflictos entre las versiones de los módulos. Puede instalar una versión específica de un paquete o puede actualizar el paquete a la última versión. Esto garantiza que su proyecto sea compatible con todas las dependencias requeridas.
- Soporte de línea de comando. El uso de comandos CLI le permite automatizar la instalación y la gestión de dependencias.

El uso de npm facilita mucho el desarrollo de proyectos de Node.js, razón por la cual se ha convertido en uno de los administradores de paquetes más populares del mundo.

## Descripción general de cómo funciona npm

Para trabajar con npm necesitas instalar Node.js.

Para publicar paquetes en espacios de nombres, debe crear una cuenta en npmjs.com y configurar la autenticación de dos factores (opcional, pero recomendada).

Un paquete es un archivo o directorio descrito en el archivo **package.json** adjunto. Este archivo es necesario para publicar el paquete en el registro npm.

Echemos un vistazo más de cerca a los procesos de instalación y creación de paquetes.

### Instalación de paquetes

Los paquetes se pueden instalar local o globalmente.

#### Instalación local

Instale el paquete localmente si su propio módulo depende de él, por ejemplo si está especificado en la función **require()**. Este es el comportamiento predeterminado de npm.

##### Instalación de un paquete desde el espacio de nombres global (paquete sin ámbito)

Los paquetes del espacio de nombres global siempre son públicos. Cualquier usuario puede encontrar dicho paquete, descargarlo e instalarlo.

Para instalar un paquete público, ejecute el siguiente comando en el directorio de su proyecto:

```Shell
npm install <package_name>
```

Se creará un directorio llamado **node_modules** en el directorio actual (si aún no se ha creado) y se descargará en él la versión más reciente del paquete.

##### Instalación de un paquete público desde un espacio de nombres específico (paquete público con alcance)

Cualquiera puede descargar e instalar un paquete público de un espacio de nombres específico si el nombre del espacio de nombres se especifica durante la instalación:

```Shell
npm install @scope/package-name
```

##### Instalar un paquete privado

Los paquetes privados (privados) solo pueden ser descargados por aquellos a quienes se les ha otorgado acceso de lectura a esos paquetes. Estos paquetes siempre pertenecen a un espacio de nombres y deben especificarse durante la instalación:

```Shell
npm install @scope/private-package-name
```

#### Instalación global

Para ejecutar paquetes globalmente, se recomienda utilizar npx, una utilidad para ejecutar paquetes npm.

Si un paquete está instalado globalmente, puede usar su código como un conjunto de herramientas en su computadora local.

Para descargar e instalar el paquete globalmente, ejecute el siguiente comando en el símbolo del sistema:

```Shell
npm install -g <package_name>

```

Si se produce un error de permisos de EACCES, es posible que deba reinstalar npm usando el administrador de versiones o cambiar manualmente el directorio predeterminado.

### Colocación del paquete

Para colocar un paquete en el registro, necesita un archivo **package.json**, que contiene una descripción del paquete. Hace que el paquete sea fácil de instalar y administrar. En el archivo **package.json**:

- enumera los paquetes de los que depende su proyecto;
- especifica las versiones de paquetes que su proyecto puede usar;
- El diseño es reproducible para compartirlo fácilmente con otros desarrolladores.

Para facilitar la búsqueda, se recomienda utilizar un campo de _descripción_ personalizado en el archivo **package.json**.

El archivo package.json se puede crear de dos maneras: (1) respondiendo preguntas en la CLI o (2) creando un package.json predeterminado.

Para crear un archivo de la primera manera:

- En la línea de comando, vaya al directorio raíz de su módulo Node.js y ejecute **npm init**:

  - para un módulo con un espacio de nombres, ejecute **npm init --scope=@scope-name**;
  - Para un módulo en el espacio de nombres global, ejecute **npm init**.

- Especifique valores para los campos obligatorios (**name** y **version**), así como el campo **main**:
  - **name**: nombre del módulo.
  - **version**: versión inicial del módulo.
  - **main**: un identificador de módulo que sirve como punto de entrada principal a su programa. Si no se establece este valor, el valor predeterminado es el archivo index.js en la raíz del paquete.

Para crear un archivo package.json predeterminado, ejecute **npm init --yes**.

Los campos **name** y **version** son obligatorios, independientemente de cómo cree el archivo **package.json**:

- El campo **name** contiene el nombre del paquete. El nombre debe ser una palabra y puede contener caracteres en minúscula, guión y guión bajo.
- El valor en el campo **version** debe cumplir con las pautas de control de versiones semánticas. Se indican tres números mediante un punto: la versión principal actual, la versión menor actual y los cambios menores. Por ejemplo, 1.1.0.

Si desea proporcionar información sobre el autor de un paquete, utilice el siguiente formato:

```
My name my@email.com (http://website.com)
```

Todo el código para crear e inicializar el archivo **package.json** podría verse así:

```json
{
  "name": "my-cool-package",
  "version": "1.0.0",
  "author": My name my@email.com (http://website.com)
}
```

### Archivo para cargar un módulo usando require()

La función **require()** es una función de Node.js para cargar módulos. Sus argumentos incluyen el nombre del módulo que necesitamos.

**require()** puede ser útil si queremos utilizar un módulo de terceros en nuestro paquete. Para crear un archivo **package.json** usando esta función, declararlo como una propiedad del objeto **exports**. Esto le dará acceso al código de terceros:

```
exports.logMsg = function() {
  console.log("Hello!");
}
```

### Crear y publicar un paquete público en el espacio de nombres global

- en la línea de comando, cree un directorio de paquetes;
- vaya al directorio del paquete;
- en el directorio raíz del paquete, ejecute el comando **npm init**;
- responda las preguntas para crear un archivo **package.json**;
- cree un archivo README que describa el código y las instrucciones para usarlo;
- crear código de paquete;
- revise el paquete en busca de información confidencial y retírelo si está presente;
- pruebe el paquete especificando la ruta completa a su directorio: **npm install path/to/my-package**;
- Publique el paquete ejecutando el comando **npm publish** desde el directorio raíz del paquete;
- Para ver un paquete publicado, vaya a *https://npmjs.com/package/package-name* y reemplace _package-name_ con el nombre de su paquete.

> ¡Importante! No incluya información confidencial en los paquetes.

### Crear y publicar un paquete público en un espacio de nombres específico

Para publicar un paquete npm en un espacio de nombres personalizado, cree una cuenta **npm**. O, para publicar un paquete en el espacio de nombres de una organización, después de crear una cuenta, cree una organización.

- si usa npmrc para administrar cuentas, cambie al perfil deseado con el comando **npmrc <profile-name>**;
- en la línea de comando, cree un directorio de paquetes;
- vaya al directorio del paquete;
- En el directorio raíz del paquete, ejecute uno de los siguientes comandos:
  - para un paquete en el espacio de nombres de la organización (reemplace my-org con el nombre de la organización): **npm init --scope=@my-org**;
  - para un paquete en el espacio de nombres de usuario (reemplace mi-nombre de usuario con el nombre de usuario): **npm init --scope=@my-username**.
- responda las preguntas para crear un archivo **package.json**;
- cree un archivo README que describa el código y las instrucciones para usarlo;
- crear código de paquete;
- revise el paquete en busca de información confidencial y retírelo si está presente;
- pruebe el paquete especificando la ruta completa a su directorio: **npm install path/to/my-package**;
- publique el paquete ejecutando el comando **npm publish --access public** desde el directorio raíz del paquete;
- Para ver un paquete publicado, vaya a **https://npmjs.com/package/package-name**, reemplazando **package-name** con el nombre de su paquete.

## Conclusión

npm es una herramienta importante e imprescindible para desarrollar proyectos Node.js. Debido al hecho de que el repositorio npm contiene una gran cantidad de paquetes, los desarrolladores pueden agregar funcionalidad a sus proyectos de manera rápida y conveniente utilizando módulos y bibliotecas ya preparados.

Una de las principales ventajas de npm es la facilidad de instalación y gestión de dependencias. Con el comando npm install, puede instalar rápidamente todos los paquetes necesarios para un proyecto y, con la administración de dependencias, npm instala y actualiza automáticamente las dependencias de los paquetes.

Además, npm proporciona capacidades de publicación de paquetes, lo que permite a los desarrolladores compartir sus módulos y bibliotecas con otros desarrolladores de todo el mundo. De esta manera, puedes crear proyectos mejores y más eficientes a través de la interacción y colaboración entre desarrolladores.

---

# Que es Moment.Js?

![moment](images/moment.png)

[Detención del desarrollo de la biblioteca Moment.js](https://momentjs.com/docs/#/-project-status/)

Los desarrolladores de la biblioteca JavaScript **Moment.js** han anunciado que dejarán de desarrollar y trasladarán el proyecto al modo de mantenimiento, lo que significa detener la expansión de la funcionalidad, congelar la API y limitar la actividad para corregir errores graves, que reflejan los cambios de la base de datos de zona horaria. y mantener la infraestructura para los usuarios existentes. No se recomienda utilizar **Moment.js** para proyectos nuevos.

La biblioteca **Moment.js** proporciona funciones para manipular la hora y las fechas y es el estándar de facto en su campo. La biblioteca se descarga aproximadamente 12 millones de veces por semana. El motivo de la decisión fue darse cuenta de que el proyecto estaba desactualizado y no encajaba en los paradigmas modernos de desarrollo de JavaScript. Las desventajas incluyen el tamaño relativamente grande de la biblioteca (329 KB sin compresión, 70 KB con compresión) y el uso de objetos mutables (mutables, cambiar una copia del objeto momento al detener el desarrollo de la biblioteca **Moment.js** conduce a cambiar el original).

Las revisiones también mencionan problemas con **Moment.js**, como bajo rendimiento, API confusa, falta de soporte para _"Tree shake"_ (recortar el código no utilizado para reducir el tamaño de una aplicación web) y una depuración que requiere mucha mano de obra. Aparentemente, la gota que colmó el vaso que empujó a los desarrolladores a tomar la decisión de mover **Moment.js** al modo de mantenimiento fue un cambio en el sistema de auditoría de páginas web de Lighthouse integrado en las herramientas para desarrolladores web de Chrome; hace unos días, Lighthouse comenzó a emitir una advertencia sobre código excesivo. Infle **Moment.js** y sugiera alternativas de reemplazo.

Los navegadores modernos proporcionan una API **Intl** incorporada para trabajar con configuraciones regionales y zonas horarias. Esta API se utiliza en la biblioteca **Luxon**, creada por uno de los contribuyentes de **Moment.js** y promocionada como el siguiente paso en la evolución de **Moment.js**. Además de **Luxon**, las bibliotecas **Day.js** (una versión minimalista de **Moment.js** con una API similar, ocupa alrededor de 7 KB sin complementos), **date-fns**, **js-joda** (puerto **java.time**) y JavaScript estándar **Date** y **Intl**, así como el borrador de la API temporal.

---

# Es importante la documentación en los paquetes? explique

![docs](images/docs.png)

La preparación de la documentación del software es una etapa muy importante en el proceso de desarrollo y lanzamiento. Lamentablemente, no todas las empresas le prestan la suficiente atención, lo que afecta negativamente tanto al mantenimiento y desarrollo del software como a la interacción con sus usuarios.

## ¿Qué es la documentación técnica del software? Sus tipos y formatos

La documentación de software es un conjunto de documentos que describen en detalle las características técnicas y las cualidades de consumo del software, así como información sobre el proceso de su desarrollo, aplicación y mantenimiento.

El paquete de documentación del software incluye no sólo materiales técnicos, sino también muchos otros tipos de documentos. Estos incluyen manuales, instrucciones de usuario y ayuda, revisiones de software, especificaciones, técnicas de prueba, etc. Para facilitar la clasificación, toda esta documentación se divide en 4 categorías:

- **Diseño (arquitectónico)**. Describe los fundamentos, metas, objetivos y fases del proyecto que se aplican a la creación de software y su entorno operativo. Es una descripción general del software, destinada principalmente a los especialistas que trabajan en el proyecto.
- **Técnico**. En ocasiones, este es el nombre que se le da a absolutamente toda la documentación de software, aunque esto no es del todo cierto. La propia documentación técnica incluye una descripción del código del programa y las funciones que realiza, estructuras de datos, algoritmos, API e interfaces. Además, muestra en detalle el proceso de desarrollo de software, su principio de funcionamiento y procedimiento operativo. A menudo, estos materiales se suministran completos con el código fuente del programa o están integrados en forma de comentarios. Para simplificar la creación y actualización de documentos técnicos, se utilizan plantillas especiales o esto se hace de forma automática mediante generadores de documentación (Javadoc, Doxygen, NDoc, etc.).
- **Costumbre**. Si los dos primeros tipos de materiales están dirigidos a especialistas, esta categoría está destinada a usuarios de software. No contiene descripciones técnicas complejas del código y cómo funciona, sino que se centra en describir las funciones del software y cómo utilizarlo. Los formatos más comunes para la documentación del usuario incluyen la Guía del usuario y la Referencia del usuario. También suele contener instrucciones para resolver problemas y respuestas a preguntas frecuentes.
- **Marketing**. Otro tipo principal de documentación de software son los materiales de marketing, que ayudan a atraer la atención del público objetivo hacia el producto, informan sobre su propósito, capacidades y ventajas. A diferencia de la documentación de usuario, la documentación de marketing es mucho más concisa. A menudo consiste en un único folleto publicitario diseñado para familiarizar al usuario con el programa o aplicación.

## ¿Cómo debería ser la documentación de calidad?

En primer lugar, debe cumplir una serie de normas determinadas. A saber, tales como:

- **Estructuración**. Tener una estructura clara es uno de los requisitos más importantes para la documentación técnica. Debe estar organizado lógicamente en secciones y subsecciones, tener párrafos, listas y otros elementos de formato de texto. Si hablamos de manuales de usuario, entonces una descripción de texto por sí sola no es suficiente; debe complementarse con capturas de pantalla de alta calidad del programa. No menos populares son los manuales en vídeo, que, sin embargo, no pueden reemplazar completamente los materiales de texto.
- **Uniformidad**. Toda la documentación del software debe redactarse en un formato unificado, incluidos los documentos técnicos y de diseño para los empleados y los materiales para los usuarios. Además, a medida que lo redactes, debes consultar con otros documentos emitidos por tu empresa para mantener un estilo corporativo coherente. También sería una buena idea estandarizar el proceso de preparación de la documentación con antelación para evitar discrepancias en el futuro.
- **Contenido de informacion**. Otra característica importante de la documentación de software de alta calidad es su claridad y contenido informativo. Para lograr este objetivo, es necesario poder lograr un equilibrio entre el volumen de datos y la simplicidad de su presentación. Tanto la falta como el exceso de información pueden empeorar este indicador, especialmente cuando se trata de documentación de usuario. Por un lado, no es necesario hacerlo demasiado superficial y simplificado y, por otro lado, no se debe permitir que el material se vuelva demasiado complicado.
- **Relevancia**. Una buena documentación técnica debe estar destinada a un público objetivo específico. Crear una guía universal común para desarrolladores y usuarios es una tarea interesante, pero difícil, que probablemente no sea posible ni siquiera para un escritor técnico experimentado. Antes de desarrollar materiales, conviene determinar el círculo de empleados o clientes para quienes resultarán más útiles e interesantes. También es necesario tener una idea del nivel de preparación de la audiencia y qué tareas y problemas puede resolver esta documentación.

## ¿Qué son los términos de referencia y el diseño técnico?

Como regla general, no es necesario redactar toda la documentación técnica antes de comenzar el desarrollo del software. La mayoría de las veces, los proyectos de TI modernos se crean utilizando la metodología Agile y el trabajo en ellos se lleva a cabo en sprints, lo que permite escribir documentación en paralelo con el proceso de desarrollo.

Sin embargo, hay varios documentos que idealmente deberían prepararse antes de comenzar el desarrollo de software: estos incluyen las especificaciones técnicas (TOR) y el diseño técnico (TP).

La especificación técnica es un documento preliminar clave; proporciona una descripción general y el propósito del programa, sus objetivos comerciales, el alcance de trabajo esperado, así como el orden de las etapas de desarrollo, evaluación y aceptación del software. La especificación técnica la elabora un analista de negocios después de negociar con el cliente, por lo que es necesario registrar con precisión y detalle todos sus requisitos y visión del programa futuro. Si es necesario, también se discute con los miembros del equipo implementador del proyecto: desarrolladores, diseñadores, directores de proyecto, etc. De hecho, se trata de un planteamiento del problema expresado en forma documental.

Después de redactar y acordar las especificaciones técnicas, se comienza a trabajar en el proyecto técnico, que ya está elaborado por un redactor técnico, no por un analista de negocios. TP es un conjunto de materiales que describe la arquitectura, escenarios, métodos, enfoques, soluciones técnicas y otros datos utilizados en el desarrollo del programa. Por ejemplo, un proyecto técnico muestra la estructura de servidores y bases de datos, diseños de interfaz, descripciones de algoritmos e integraciones con sistemas o equipos externos, escenarios de usuario, etc.

En términos simples, si la especificación técnica responde a la pregunta "¿qué hay que hacer?", entonces el proyecto técnico responde a la pregunta "¿cómo hacerlo?".

## ¿Qué es un redactor técnico? Características, tareas y problemas de esta profesión.

El desarrollo de documentación técnica para software lo lleva a cabo un redactor técnico (escritor técnico). Prepara casi todo tipo de materiales, incluidos manuales de usuario y libros de referencia, proyectos técnicos para especialistas, textos de marketing, etc. Las responsabilidades laborales de un redactor técnico incluyen:

- Elaboración de documentación técnica de acuerdo con normas internas (corporativas), estatales o internacionales.
- Realizar cambios y adiciones a la documentación a medida que se actualiza el software, manteniéndolo actualizado.
- Elaboración de materiales gráficos y multimedia (esquemas, gráficos, capturas de pantalla, guías en video) de acuerdo con parámetros especificados e ingreso a la documentación técnica.
- Pruebas y análisis de nuevos programas y aplicaciones, aplicación de la experiencia y conocimientos adquiridos en la preparación de documentación.
- Recopilar la información necesaria sobre el software de todos los participantes del proyecto: desarrolladores, gerentes, diseñadores, evaluadores, clientes, etc.
- Traducción de documentación técnica a idiomas extranjeros, preparación de presentaciones técnicas, participación en procesos de implementación de software.

Idealmente, un escritor técnico profesional es un humanista con formación técnica que comprende los conceptos básicos del desarrollo de TI, conoce terminología especializada, conoce algunos lenguajes de programación y lenguajes de marcado, así como herramientas para automatizar procesos de documentación. Al mismo tiempo, debe tener ciertas habilidades filológicas para poder redactar material técnico de manera concisa, informativa y comprensible tanto para los especialistas como para los usuarios comunes.

Sin embargo, tal versatilidad y multitarea están al alcance de pocos, razón por la cual las empresas de TI a menudo se quejan de la dificultad de encontrar un buen redactor técnico. Por un lado, sus desarrolladores son las mejores personas para hablar de software, pero no saben cómo presentar el programa de forma concisa y comprensible para un no especialista. Y los autores de textos profesionales, por regla general, no entienden de programación, por lo que no pueden describir de manera precisa e informativa la estructura, funciones y otros matices técnicos del software.

---

# Manejo de errores en JavaScript

![js error](images/js_error.png)

## Errores en JavaScript y formas universales de trabajar con ellos.

Si algo sale mal en su código, puede utilizar la siguiente construcción.

```JavaScript
throw new Error('something went wrong')

```

Cuando se ejecuta este comando, se creará una instancia del objeto **Error** y se generará una excepción (o, como dicen, "lanzará") con este objeto. La declaración **throw** puede generar excepciones que contengan expresiones arbitrarias. En este caso, la ejecución del script se detendrá si no se han tomado medidas para solucionar el error.

Los programadores principiantes de JS generalmente no usan la declaración **throw**. Por lo general, encuentran excepciones generadas por el tiempo de ejecución del lenguaje o por bibliotecas de terceros. Cuando esto sucede, aparece algo como _ReferenceError: fs is not defined_ en la consola y la ejecución del programa se detiene.

### Objeto de error

Las instancias del objeto **Error** tienen varias propiedades que podemos usar. La primera propiedad que nos interesa es el mensaje. Aquí es donde termina la cadena que se puede pasar al constructor de error como argumento. Por ejemplo, a continuación se muestra la creación de una instancia del objeto **Error** y la salida a la consola de la cadena pasada por el constructor al acceder a su propiedad **message**.

```JavaScript
const myError = new Error('please improve your code')
console.log(myError.message) // please improve your code
```

La segunda propiedad del objeto, que es muy importante, es el seguimiento de la pila de errores. Esta es la propiedad **stack**. Al acceder a él, puede ver la pila de llamadas (historial de errores), que muestra la secuencia de operaciones que llevaron al funcionamiento incorrecto del programa. En particular, esto le permite comprender qué archivo contiene el código defectuoso y ver qué secuencia de llamadas a funciones provocaron el error. A continuación se muestra un ejemplo de lo que puede ver accediendo a la propiedad **stack**.

```JavaScript
Error: please improve your code
 at Object.<anonymous> (/Users/gisderdube/Documents/_projects/hacking.nosync/error-handling/src/general.js:1:79)
 at Module._compile (internal/modules/cjs/loader.js:689:30)
 at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)
 at Module.load (internal/modules/cjs/loader.js:599:32)
 at tryModuleLoad (internal/modules/cjs/loader.js:538:12)
 at Function.Module._load (internal/modules/cjs/loader.js:530:3)
 at Function.Module.runMain (internal/modules/cjs/loader.js:742:12)
 at startup (internal/bootstrap/node.js:266:19)
 at bootstrapNodeJSCore (internal/bootstrap/node.js:596:3)
```

Aquí, en la parte superior, hay un mensaje de error, seguido de una indicación de la sección de código cuya ejecución causó el error, luego una descripción del lugar desde donde se llamó esta sección defectuosa. Esto continúa hasta que el fragmento de código está "más alejado" del error.

## Generación y manejo de errores.

Crear una instancia del objeto **Error**, es decir, ejecutar un comando como **new Error()**, no tiene consecuencias especiales. Empiezan a suceder cosas interesantes después de usar el operador **throw**, que genera un error. Como ya se mencionó, si no se soluciona dicho error, la ejecución del script se detendrá. No importa si el operador **throw** fue utilizado por el propio programador o si se produjo un error en una determinada biblioteca o en el entorno de ejecución del lenguaje (en el navegador o en Node.js). Hablemos de diferentes escenarios de manejo de errores.

### La construcción try...catch

El bloque **try...catch** es la forma más sencilla y a menudo pasada por alto de manejar errores. Hoy en día, sin embargo, se usa mucho más intensamente que antes, debido al hecho de que puede usarse para manejar errores en construcciones **async/await**.

Este bloque se puede utilizar para manejar cualquier error que ocurra en el código sincrónico. Veamos un ejemplo.

```JavaScript
const a = 5

try {
    console.log(b) // la variable b no está declarada - se produce un error
} catch (err) {
    console.error(err) // el mensaje de error y la pila de errores se envían a la consola
}

console.log(a) // la ejecución del script no se detiene, este comando se ejecuta
```

Si en este ejemplo no hubiéramos incluido el comando fallido _console.log(b)_ en un bloque **try...catch**, el script habría dejado de ejecutarse.

### Bloque finally

A veces sucede que es necesario ejecutar algún código independientemente de si ocurrió un error o no. Para hacer esto, puede usar el tercer bloque opcional en la construcción **try...catch** - **finally**. A menudo su uso equivale a algún código que viene inmediatamente después de **try...catch**, pero en algunas situaciones puede resultar útil. A continuación se muestra un ejemplo de su uso.

```JavaScript
const a = 5

try {
    console.log(b) // la variable b no está declarada: se produce un error
} catch (err) {
    console.error(err) // Aparecen un mensaje de error y una pila de errores en la consola.
} finally {
    console.log(a) // este código se ejecutará de todos modos
}
```

## Mecanismos asincrónicos: devoluciones de llamada

Al programar en JavaScript, siempre debes prestar atención a las secciones de código que se ejecutan de forma asincrónica. Si tiene una función asincrónica y arroja un error, el script continuará ejecutándose. Cuando se implementan mecanismos asincrónicos en JS mediante devoluciones de llamada (por cierto, esto no se recomienda), la devolución de llamada correspondiente (función de devolución de llamada) generalmente recibe dos parámetros. Esto es algo así como un parámetro err, que puede contener un error y un resultado, con los resultados de una operación asincrónica. Se parece a esto:

```JavaScript
myAsyncFunc(someInput, (err, result) => {
    if(err) return console.error(err)
    console.log(result)
})
```

Si se envía un error a la devolución de llamada, es visible allí como el parámetro err. De lo contrario, este parámetro contendrá el valor indefinido o nulo. Si resulta que hay algo en error, es importante reaccionar ante ello, ya sea como en nuestro ejemplo, usando el comando return, o usando la construcción if...else y colocando comandos en el bloque else para trabajar con el resultado de la operación asincrónica. La cuestión es que, en caso de que se produzca un error, para excluir la posibilidad de trabajar con el resultado, se utiliza el parámetro resultado, que en este caso puede tener el valor indefinido. Trabajar con un valor de este tipo si se supone, por ejemplo, que contiene un objeto, puede provocar un error. Digamos que esto sucede cuando intentas utilizar la construcción result.data o algo similar.

## Mecanismos asincrónicos: promesas

Para realizar operaciones asincrónicas en JavaScript, es mejor utilizar promesas en lugar de devoluciones de llamada. Aquí, además de una mejor legibilidad del código, también existen mecanismos de manejo de errores más avanzados. Es decir, no hay necesidad de perder el tiempo con un objeto de error que podría terminar en una función de devolución de llamada cuando se usan promesas. Para ello está previsto un bloque de captura especial. Detecta todos los errores que ocurrieron en las promesas anteriores, o todos los errores que ocurrieron en el código después del bloque catch anterior. Tenga en cuenta que si hay un error en la promesa de que no hay ningún bloque catch que manejar, esto no detendrá la ejecución del script, pero el mensaje de error no será particularmente legible.

```JavaScript
(node:7741) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: something went wrong
(node:7741) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. */
```

Como resultado, siempre podemos recomendar el uso de un bloque catch cuando trabajemos con promesas. Veamos un ejemplo.

```JavaScript
Promise.resolve(1)
    .then(res => {
        console.log(res) // 1

        throw new Error('something went wrong')

        return Promise.resolve(2)
    })
    .then(res => {
        console.log(res) // este bloque no se ejecutará
    })
    .catch(err => {
        console.error(err) // hablaremos sobre qué hacer con este error más adelante
        return Promise.resolve(3)
    })
    .then(res => {
        console.log(res) // 3
    })
    .catch(err => {
        // este bloque está aquí por si hay algún error en el bloque anterior
        console.error(err)
    })
```

### Mecanismos asincrónicos y try...catch

Después de que apareció la construcción **async/await** en JavaScript, volvimos a la forma clásica de manejar errores: **try...catch...finally**. Manejar errores con este enfoque resulta muy fácil y conveniente. Veamos un ejemplo.

```JavaScript
;(async function() {
    try {
        await someFuncThatThrowsAnError()
    } catch (err) {
        console.error(err)
    }

    console.log('Easy!')
})()
```

Con este enfoque, los errores en el código asincrónico se manejan de la misma manera que en el código sincrónico. Como resultado, ahora se puede manejar una gama más amplia de errores en un solo bloque catch si es necesario.

## Generar y manejar errores en el código del servidor.

Ahora que tenemos herramientas para trabajar con errores, veamos qué podemos hacer con ellos en situaciones reales. Generar y manejar correctamente errores es un aspecto crítico de la programación del servidor. Existen diferentes enfoques para abordar los errores. Aquí demostraremos un enfoque que utiliza un constructor personalizado para instancias del objeto Error y códigos de error, que son convenientes para pasar al frontend o a cualquier mecanismo que utilice API del lado del servidor. Realmente no importa cómo esté estructurado el backend de un proyecto en particular, ya que con cualquier enfoque puedes usar las mismas ideas con respecto a trabajar con errores.

Usaremos Express.js como marco del lado del servidor responsable del enrutamiento. Pensemos en qué tipo de estructura necesitamos para organizar un sistema eficaz de manejo de errores. Así que esto es lo que necesitamos:

- El manejo universal de errores es un mecanismo básico adecuado para manejar cualquier error, durante el cual simplemente emite un mensaje como Algo salió mal, inténtelo de nuevo o contáctenos, solicitando al usuario que intente nuevamente la operación fallida o que se comunique con el propietario del servidor. Este sistema no es especialmente inteligente, pero al menos es capaz de informar al usuario de que algo ha ido mal. Un mensaje como este es mucho mejor que “carga infinita” o algo similar.
- El manejo de errores específicos es un mecanismo que permite proporcionar al usuario información detallada sobre los motivos del comportamiento incorrecto del sistema y brindarle consejos específicos sobre cómo combatir el problema. Por ejemplo, esto puede deberse a la ausencia de algunos datos importantes en la solicitud que el usuario envía al servidor, o al hecho de que ya existe un determinado registro en la base de datos que está intentando agregar nuevamente, etc.

### Desarrollando su propio constructor de objetos de error

Aquí usaremos la clase estándar **Error** y la ampliaremos. Usar mecanismos de herencia en JavaScript es un negocio arriesgado, pero en este caso estos mecanismos resultan muy útiles. ¿Por qué necesitamos la herencia? El hecho es que, para que el código se pueda depurar cómodamente, necesitamos información sobre el seguimiento de la pila de errores. Al ampliar la clase estándar **Error**, obtenemos capacidades de seguimiento de pila sin ningún esfuerzo adicional. Agregamos dos propiedades a nuestro propio objeto de error. La primera es la propiedad code, a la que se puede acceder mediante una construcción como err.code. La segunda es la propiedad de estado. Contendrá el código de estado HTTP, que está previsto transmitir a la parte del cliente de la aplicación.

Así es como se ve la clase **CustomError**, cuyo código está formateado como un módulo.

```JavaScript
class CustomError extends Error {
    constructor(code = 'GENERIC', status = 500, ...params) {
        super(...params)

        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CustomError)
        }

        this.code = code
        this.status = status
    }
}

module.exports = CustomError
```

### Enrutamiento

Ahora que nuestro objeto de error está listo para usarse, necesitamos configurar nuestra estructura de ruta. Como se mencionó anteriormente, necesitamos implementar un enfoque unificado para el manejo de errores que nos permita manejar los errores por igual para todas las rutas. De forma predeterminada, el marco Express.js no es totalmente compatible con este esquema de trabajo. El caso es que todas sus rutas están encapsuladas.

Para solucionar este problema, podemos implementar nuestro propio controlador de ruta y definir la lógica de ruta como funciones regulares. Con este enfoque, si la función de ruta (o cualquier otra función) arroja un error, se pasará al controlador de ruta, que luego podrá pasarlo al lado cliente de la aplicación. Cuando ocurre un error en el servidor, planeamos pasarlo al frontend en el siguiente formato, asumiendo que se usará JSON-API para esto:

```JavaScript
{
    error: 'SOME_ERROR_CODE',
    description: 'Something bad happened. Please try again or contact support.'
}
```

Si en esta etapa lo que está sucediendo no le parece claro, no se preocupe, simplemente siga leyendo, intente trabajar con lo que se dice y gradualmente comprenderá todo. De hecho, cuando se trata de formación en informática, se necesita un enfoque de arriba hacia abajo, discutiendo primero las ideas generales y luego pasando a las específicas.

Así es como se ve el código del controlador de ruta.

```JavaScript
const express = require('express')
const router = express.Router()
const CustomError = require('../CustomError')

router.use(async (req, res) => {
    try {
        const route = require(`.${req.path}`)[req.method]

        try {
            const result = route(req)
            res.send(result)
        } catch (err) {
            if (err instanceof CustomError) {

                return res.status(err.status).send({
                    error: err.code,
                    description: err.message,
                })
            } else {
                console.error(err)

                return res.status(500).send({
                    error: 'GENERIC',
                    description: 'Something went wrong. Please try again or contact support.',
                })
            }
        }
    } catch (err) {
        res.status(404).send({
            error: 'NOT_FOUND',
            description: 'The resource you tried to access does not exist.',
        })
    }
})

module.exports = router
```

Creemos que los comentarios del código lo explican bastante bien. Esperamos que sean más fáciles de leer que las explicaciones de códigos similares que se dan a continuación.

Ahora echemos un vistazo al archivo de rutas.

```JavaScript
const CustomError = require('../CustomError')

const GET = req => {
    return { name: 'Rio de Janeiro' }
}

const POST = req => {
    throw new Error('Some unexpected error, may also be thrown by a library or the runtime.')
}

const DELETE = req => {
    throw new CustomError('CITY_NOT_FOUND', 404, 'The city you are trying to delete could not be found.')
}

const PATCH = req => {
    try {
        throw new Error('Some internal error')
    } catch (err) {
        console.error(err)

        throw new CustomError(
            'CITY_NOT_EDITABLE',
            400,
            'The city you are trying to edit is not editable.'
        )
    }
}

module.exports = {
    GET,
    POST,
    DELETE,
    PATCH,
}
```

En estos ejemplos, no se hace nada con las consultas en sí. Aquí simplemente consideramos diferentes escenarios de error. Entonces, por ejemplo, una solicitud GET /city irá a la función const GET = req =>..., una solicitud POST /city irá a la función const POST = req =>..., y así sucesivamente. Este esquema también funciona cuando se utilizan parámetros de consulta. Por ejemplo, para una solicitud como GET /city?startsWith=R. En general, demuestra que al manejar errores, la interfaz puede recibir un error general que contiene solo una sugerencia para volver a intentarlo o contactar al propietario del servidor, o un error generado usando el constructor CustomError, que contiene información detallada sobre el problema.
Los datos del error general llegarán a la parte cliente de la aplicación de la siguiente forma:

```JavaScript
{
    error: 'GENERIC',
    description: 'Something went wrong. Please try again or contact support.'
}
```

El constructor CustomError se utiliza así:

```JavaScript
throw new CustomError('MY_CODE', 400, 'Error description')
```

Esto produce el siguiente código JSON pasado al frontend:

```JavaScript
{
    error: 'MY_CODE',
    description: 'Error description'
}
```
